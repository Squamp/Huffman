import java.io.*;
import java.util.HashMap;
import java.util.PriorityQueue;
import java.util.Scanner;
import java.util.TreeMap;

/**
 * Created by Sean 2/20/2017.
 *
 * Program that uses the Huffman encoding algorithm to compress a file and then be able to decompress
 * it at a later time.
 */
public class Huffman {


    public static TreeMap<String,Value> freqMap = new TreeMap<>(); //map to hold the frequencies of each character
    public static HashMap<String, String> huffMap = new HashMap<>(); //map to hold the Huffman code of each character

    public static void main(String[] args) {
        encode("mcgee.txt",
                "mcgee.code", "mcgee.compressed");

        decode("mcgee.compressed", "mcgee.code",
                "mcgeedecompressed.txt");
    }

    /**
     * Method that takes a file as input and outputs two additional files, one that contains the ascii value
     * of each letter and one that contains the encoded version of the file using the huffman encoding.
     *
     * @param originalFilename The original file to be encoded
     * @param codeFilename file containing the ascii value and codes
     * @param compressedFilename the encoded file
     */
    public static void encode (String originalFilename, String codeFilename, String compressedFilename ){

        try {

            int i;

            BitOutputStream compressedFile = new BitOutputStream(compressedFilename);
            RandomAccessFile originalFile = new RandomAccessFile(originalFilename, "r");
            int b = originalFile.read();

            BufferedWriter fout = new BufferedWriter(new FileWriter(codeFilename));

            for(i = 1; i < 257; i++){

                Value value = new Value();
                value.freq = readCharFreq
                        (originalFilename)[i];
                value.c = (char) i;
                freqMap.put((char) i + "" ,value);
            }

            Value tree = huffman(freqMap);

            tree.genCodes(tree.huff);

            for (i = 1; i < 257; i++) {
                if(!freqMap.get((char) i + "").huff.equals("")){
                    fout.write( freqMap.get((char) i + "").huff + "\t" + (int)freqMap.get((char) i + "").c + "\n");
                }
            }

            fout.close();

            while (b != -1){
                if (huffMap.containsKey((char)b + "")){
                    compressedFile.writeString(huffMap.get((char)b + ""));
                }
                b = originalFile.read();
            }

            compressedFile.close();

        }
        catch (Exception e){
            System.err.println("Problem opening file");
            System.err.println(e.getMessage());
            System.exit(1);
        }
    }


    /**
     * Method that reads in the code file and the compressed file generated by the encode method to
     * decode the compressed file.
     *
     * @param compressedFilename The compressed file generated by the encode method
     * @param codeFilename the file containing the Huffman codes generated by the encode method
     * @param decompressedFilename the final decompressed file that should match the original file.
     */
    public static void decode(String compressedFilename, String codeFilename, String decompressedFilename){

        try {
            HashMap<String, String> decodeMap = new HashMap<>();

            BufferedWriter decompressedOut = new BufferedWriter(new FileWriter(decompressedFilename));
            Scanner codeIn = new Scanner(new File(codeFilename));

            BitInputStream fin = new BitInputStream(compressedFilename);
            int next = fin.nextBit();

            StringBuilder temp = new StringBuilder();

            while (codeIn.hasNext()){
                decodeMap.put(codeIn.next(), (char) codeIn.nextInt() + "");
            }

            while (next != -1){

                temp = temp.append(next);
                next = fin.nextBit();

                if(decodeMap.containsKey(temp + "")){
                    decompressedOut.write(decodeMap.get(temp.toString()));
                    temp = new StringBuilder();
                }

            }

            decompressedOut.close();

        }

        catch (Exception e){
            System.err.println("Problem opening file");
            System.err.println(e.getMessage());
            System.exit(1);
        }

    }

    /**
     * Method that adds all unique characters from the file to a PriorityQueue and compares them by frequency.
     *
     * @param values A treemap containing the frequencies of each character stored as value objects
     * @return a tree of value objects containing the Huffman codes for each letter in the file
     */
    public static Value huffman(TreeMap<String,Value> values) {
        int i;
        PriorityQueue<Value> priorityQueue = new PriorityQueue<>();

        for (i = 1; i <= values.size(); i++){
            Value v = values.get((char) i + "");
            if(v.freq != 0) {
                priorityQueue.add(values.get((char) i + ""));
            }
        }

        while (priorityQueue.size() > 1) {
            Value z = new Value();
            Value goLeft = priorityQueue.poll();
            Value goRight = priorityQueue.poll();
            z.left = goLeft;
            z.right = goRight;
            z.freq = goLeft.freq + goRight.freq;
            priorityQueue.add(z);
        }

        return priorityQueue.poll();

    }

    /**
     * method to read in a file bit by bit and return an array containing the frequencies of each character in the file
     *
     * @param fileName the name of the file to be read in
     * @return returns an array containing the frequency of each character in the file where the index of the array
     * matches the ascii value of the character
     * @throws Exception throws an exception if there is an error reading the file
     */
    public static int[] readCharFreq(String fileName) throws Exception{

        RandomAccessFile fin = new RandomAccessFile(fileName, "r");;
        int[] charFreqArr = new int[257];
        int input = fin.read();

        while(input != -1) {
            charFreqArr[input]++;
            input = fin.read();
        }

        return charFreqArr;

    }


    /**
     * Value object to be added to the treemap acts as a treenode and also as a tree
     */
    public static class Value implements Comparable<Value>{

        private char c; //the character contained within the object
        private int freq; //the frequency of the character
        private String huff; //the Huffman code of each character
        private Value left; //the left child of the current node
        private Value right; //the right child of the current node

        //default constructor
        public Value (){
            this.freq = 0;
            this.huff = "";
        }

        //generates the Huffman code for the character in the object
        public void genCodes(String str){
            if (left == null && right == null) {
                huffMap.put(c + "", str);
                huff = str;
            }
            if(left != null)
                left.genCodes(str + "0");
            if(right != null)
                right.genCodes(str + "1");
        }

        /* method that implements the compareTo method in the comparable interface to store the
        * value objects in a PriorityQueue
        */
        public int compareTo(Value value){
            if(this.freq == value.freq) {
                return 0;
            }else if (this.freq > value.freq){
                return 1;
            }else
                return -1;

        }
    }

    public static class BitInputStream {

        private BufferedInputStream in;
        private int byt;
        private int bitMask;

        /** Constructs a BitInputStream
         * @param fileName is the name of the file
         */
        public BitInputStream(String fileName) {
            try {
                in = new BufferedInputStream(
                        new FileInputStream(
                                new File(fileName)));

                byt = in.read();
                bitMask = 0x80;
            } catch (Exception e) {
                System.err.println("Problem opening bitStream");
                System.err.println(e.getMessage());
                System.exit(1);
            }
        }

        /** readBit() returns a 0 or 1.
         *  -1 is returned at the end of file.<br><br>
         *	 There is a quirk that padded 0s are returned from
         *	 the last byte, if it is not full.
         */
        public int readBit() {
            try {
                if (bitMask == 0) {
                    bitMask = 0x80;
                    byt = in.read();
                    if (byt == -1) {
                        return -1;
                    }
                }
            } catch (Exception e) {
                System.err.println("Problem reading from BitStream");
                System.err.println(e.getMessage());
            }
            int result = ((bitMask & byt) != 0) ? 1 : 0;
            bitMask >>>= 1;
            return result;
        }

        /** nextBit() is an alias for readBit() */
        public int nextBit() {
            return readBit();
        }


    }

    public static class BitOutputStream {

        BufferedOutputStream out;
        int byt;
        int offset;

        /** constructs a BitOutStream.
         * Program exits if there is a problem
         * opening the file.
         */
        public BitOutputStream(String fileName) {
            try {
                out = new BufferedOutputStream(
                        new FileOutputStream(
                                new File(fileName)));

                offset = 8;
            } catch (Exception e) {
                System.err.println("Problem opening BitOutputStream");
                System.err.println(e.getMessage());
                System.exit(1);
            }
        }

        /** Writes one bit to the file */
        public void writeBit(int bit) {
            byt <<= 1;
            byt += bit;
            offset -= 1;

            try {
                if (offset == 0) {
                    offset = 8;
                    out.write(byt);
                    byt = 0;
                }
            } catch (Exception e) {
                System.err.println("Problem writing to BitOutputStream");
                System.err.println(e.getMessage());
            }
        }

        /**
         * Write the bits contained in a String to the file.  The String is
         * interpreted as "1" is a 1 bit.  Any other character is a 0 bit.
         * */
        public void writeString(String bits) {
            for (int i = 0; i < bits.length(); i++) {
                int bit = (bits.charAt(i) == '1') ? 1 : 0;
                writeBit(bit);
            }
        }

        /** Closes the file.  Since the file must contain a even number of bytes,
         the final byte is padded with 0s. */
        public void close() throws IOException {
            while (offset != 8) {
                writeBit(0);
            }

            out.close();
        }

    }

}